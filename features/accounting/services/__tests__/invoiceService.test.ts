import {
  createInvoice,
  updateInvoice,
  updateInvoiceStatus,
  deleteInvoice,
  cloneInvoice,
  convertInvoiceToWorkOrder,
  syncInvoiceToWorkOrder,
  sendInvoiceReminder,
  shouldShowValidationModal,
} from '../invoiceService';
import {
  mockUser,
  mockEmployee,
  mockCustomer,
  mockQuoteItem,
  mockQuoteLabor,
  mockInvoice,
  mockWorkOrder,
} from './testHelpers';
import type { Invoice } from '../../../../types';

// Mock dependencies
jest.mock('../utils/calculations', () => ({
  calculateInvoiceTotals: jest.fn((items, labor, vatRate) => {
    const itemsSubtotal = items.reduce((sum: number, item: any) => sum + item.total, 0);
    const laborSubtotal = labor.reduce((sum: number, labor: any) => sum + labor.total, 0);
    const subtotal = itemsSubtotal + laborSubtotal;
    const vatAmount = subtotal * (vatRate / 100);
    const total = subtotal + vatAmount;
    return { subtotal, vatAmount, total };
  }),
  generateInvoiceNumber: jest.fn((invoices: Invoice[]) => {
    const year = new Date().getFullYear();
    const existingNumbers = invoices
      .filter((inv) => inv.invoiceNumber.startsWith(`${year}-`))
      .map((inv) => parseInt(inv.invoiceNumber.split('-')[1]))
      .filter((num) => !isNaN(num));
    const nextNumber = existingNumbers.length > 0 ? Math.max(...existingNumbers) + 1 : 1;
    return `${year}-${String(nextNumber).padStart(3, '0')}`;
  }),
}));

jest.mock('../utils/validators', () => ({
  validateInvoiceForm: jest.fn((data) => {
    if (!data.customerId) {
      return { isValid: false, message: 'Klant is verplicht!' };
    }
    if (!data.items || data.items.length === 0) {
      return { isValid: false, message: 'Minimaal 1 item is verplicht!' };
    }
    if (!data.issueDate) {
      return { isValid: false, message: 'Factuurdatum is verplicht!' };
    }
    if (!data.dueDate) {
      return { isValid: false, message: 'Vervaldatum is verplicht!' };
    }
    return { isValid: true };
  }),
}));

jest.mock('../utils/helpers', () => ({
  createHistoryEntry: jest.fn((type, action, message, user, metadata) => ({
    type,
    action,
    message,
    user: user.id,
    timestamp: new Date().toISOString(),
    metadata,
  })),
  getEmployeeName: jest.fn((id, employees) => {
    const emp = employees.find((e: any) => e.id === id);
    return emp?.name || 'Onbekend';
  }),
  getCustomerName: jest.fn((id, customers) => {
    const cust = customers.find((c: any) => c.id === id);
    return cust?.name || 'Onbekend';
  }),
  isAutoGeneratedInvoice: jest.fn((invoice: Invoice) => {
    return invoice.quoteId !== undefined;
  }),
}));

jest.mock('../../../../utils/workflowValidation', () => ({
  validateInvoiceToWorkOrder: jest.fn((invoice) => ({
    canProceed: invoice.status !== 'draft',
    message: invoice.status !== 'draft' ? 'OK' : 'Invoice is draft',
  })),
  validateInvoiceEdit: jest.fn(() => ({
    canProceed: true,
    message: 'OK',
  })),
}));

describe('invoiceService', () => {
  describe('createInvoice', () => {
    it('should create a new invoice with valid data', () => {
      const invoiceData = {
        customerId: 'cust1',
        items: [mockQuoteItem],
        labor: [mockQuoteLabor],
        vatRate: 21,
        notes: 'Test notes',
        paymentTerms: '14 dagen',
        issueDate: '2024-01-01',
        dueDate: '2024-01-15',
      };

      const invoice = createInvoice(
        invoiceData,
        mockUser,
        [mockEmployee],
        [mockCustomer],
        []
      );

      expect(invoice).toBeDefined();
      expect(invoice.customerId).toBe('cust1');
      expect(invoice.items).toEqual([mockQuoteItem]);
      expect(invoice.labor).toEqual([mockQuoteLabor]);
      expect(invoice.status).toBe('draft');
      expect(invoice.history).toHaveLength(1);
      expect(invoice.invoiceNumber).toMatch(/^\d{4}-\d{3}$/);
    });

    it('should throw error when customerId is missing', () => {
      const invoiceData = {
        customerId: '',
        items: [mockQuoteItem],
        labor: [],
        vatRate: 21,
        notes: '',
        paymentTerms: '14 dagen',
        issueDate: '2024-01-01',
        dueDate: '2024-01-15',
      };

      expect(() => {
        createInvoice(invoiceData, mockUser, [mockEmployee], [mockCustomer], []);
      }).toThrow('Klant is verplicht!');
    });

    it('should generate unique invoice number', () => {
      const existingInvoices: Invoice[] = [
        { ...mockInvoice, invoiceNumber: '2024-001' },
        { ...mockInvoice, id: 'inv2', invoiceNumber: '2024-002' },
      ];

      const invoiceData = {
        customerId: 'cust1',
        items: [mockQuoteItem],
        labor: [],
        vatRate: 21,
        notes: '',
        paymentTerms: '14 dagen',
        issueDate: '2024-01-01',
        dueDate: '2024-01-15',
      };

      const invoice = createInvoice(
        invoiceData,
        mockUser,
        [mockEmployee],
        [mockCustomer],
        existingInvoices
      );

      expect(invoice.invoiceNumber).toBe('2024-003');
    });
  });

  describe('updateInvoice', () => {
    it('should update an existing invoice', () => {
      const updatedData = {
        customerId: 'cust1',
        items: [{ ...mockQuoteItem, quantity: 3, total: 300 }],
        labor: [mockQuoteLabor],
        vatRate: 21,
        notes: 'Updated notes',
        paymentTerms: '30 dagen',
        issueDate: '2024-01-01',
        dueDate: '2024-01-31',
      };

      const updatedInvoice = updateInvoice(
        'inv1',
        updatedData,
        mockInvoice,
        mockUser,
        [mockEmployee]
      );

      expect(updatedInvoice.items[0].quantity).toBe(3);
      expect(updatedInvoice.notes).toBe('Updated notes');
      expect(updatedInvoice.paymentTerms).toBe('30 dagen');
      expect(updatedInvoice.history.length).toBeGreaterThan(mockInvoice.history.length);
    });
  });

  describe('updateInvoiceStatus', () => {
    it('should update invoice status to sent and set reminder dates', () => {
      const invoiceWithDueDate = {
        ...mockInvoice,
        dueDate: '2024-01-15',
      };

      const updatedInvoice = updateInvoiceStatus(
        invoiceWithDueDate,
        'sent',
        mockUser,
        [mockEmployee]
      );

      expect(updatedInvoice.status).toBe('sent');
      expect(updatedInvoice.timestamps?.sent).toBeDefined();
      expect(updatedInvoice.reminders).toBeDefined();
      expect(updatedInvoice.reminders?.reminder1Date).toBeDefined();
      expect(updatedInvoice.reminders?.reminder2Date).toBeDefined();
    });

    it('should update invoice status to paid and set paid date', () => {
      const updatedInvoice = updateInvoiceStatus(
        mockInvoice,
        'paid',
        mockUser,
        [mockEmployee]
      );

      expect(updatedInvoice.status).toBe('paid');
      expect(updatedInvoice.timestamps?.paid).toBeDefined();
      expect(updatedInvoice.paidDate).toBeDefined();
    });
  });

  describe('deleteInvoice', () => {
    it('should remove invoice from array', () => {
      const invoices: Invoice[] = [mockInvoice, { ...mockInvoice, id: 'inv2' }];
      const result = deleteInvoice('inv1', invoices);

      expect(result).toHaveLength(1);
      expect(result[0].id).toBe('inv2');
    });
  });

  describe('cloneInvoice', () => {
    it('should create a new invoice with same data but new ID and dates', () => {
      const clonedInvoice = cloneInvoice(
        mockInvoice,
        mockUser,
        [mockEmployee],
        [mockCustomer],
        []
      );

      expect(clonedInvoice.id).not.toBe(mockInvoice.id);
      expect(clonedInvoice.invoiceNumber).not.toBe(mockInvoice.invoiceNumber);
      expect(clonedInvoice.customerId).toBe(mockInvoice.customerId);
      expect(clonedInvoice.items).toEqual(mockInvoice.items);
      expect(clonedInvoice.status).toBe('draft');
      expect(clonedInvoice.issueDate).toBe(new Date().toISOString().split('T')[0]);
    });
  });

  describe('convertInvoiceToWorkOrder', () => {
    it('should convert invoice to work order data', () => {
      const sentInvoice: Invoice = { ...mockInvoice, status: 'sent' };
      const { workOrderData, updatedInvoice } = convertInvoiceToWorkOrder(
        sentInvoice,
        mockUser,
        [mockEmployee],
        []
      );

      expect(workOrderData).toBeDefined();
      expect(workOrderData.customerId).toBe(sentInvoice.customerId);
      expect(workOrderData.invoiceId).toBe(sentInvoice.id);
      expect(workOrderData.estimatedHours).toBe(5);
      expect(workOrderData.estimatedCost).toBe(544.5);
      expect(updatedInvoice.timestamps?.convertedToWorkOrder).toBeDefined();
    });

    it('should throw error when invoice is draft', () => {
      expect(() => {
        convertInvoiceToWorkOrder(mockInvoice, mockUser, [mockEmployee], []);
      }).toThrow();
    });
  });

  describe('syncInvoiceToWorkOrder', () => {
    it('should sync invoice data to work order', () => {
      const result = syncInvoiceToWorkOrder(mockInvoice, mockWorkOrder);

      expect(result).toBeDefined();
      expect(result?.requiredInventory).toBeDefined();
      expect(result?.estimatedHours).toBe(5);
      expect(result?.estimatedCost).toBe(544.5);
    });

    it('should return null when work order is completed', () => {
      const completedWorkOrder = { ...mockWorkOrder, status: 'Completed' as const };
      const result = syncInvoiceToWorkOrder(mockInvoice, completedWorkOrder);

      expect(result).toBeNull();
    });
  });

  describe('sendInvoiceReminder', () => {
    it('should mark reminder 1 as sent', () => {
      const invoiceWithReminders: Invoice = {
        ...mockInvoice,
        reminders: {
          reminder1Date: '2024-01-22',
          reminder1Sent: false,
          reminder2Date: '2024-01-29',
          reminder2Sent: false,
        },
      };

      const updatedInvoice = sendInvoiceReminder(
        invoiceWithReminders,
        1,
        mockUser,
        [mockEmployee]
      );

      expect(updatedInvoice.reminders?.reminder1Sent).toBe(true);
      expect(updatedInvoice.reminders?.reminder1SentDate).toBeDefined();
      expect(updatedInvoice.reminders?.reminder2Sent).toBe(false);
    });

    it('should mark reminder 2 as sent', () => {
      const invoiceWithReminders: Invoice = {
        ...mockInvoice,
        reminders: {
          reminder1Date: '2024-01-22',
          reminder1Sent: true,
          reminder2Date: '2024-01-29',
          reminder2Sent: false,
        },
      };

      const updatedInvoice = sendInvoiceReminder(
        invoiceWithReminders,
        2,
        mockUser,
        [mockEmployee]
      );

      expect(updatedInvoice.reminders?.reminder2Sent).toBe(true);
      expect(updatedInvoice.reminders?.reminder2SentDate).toBeDefined();
    });

    it('should throw error when invoice has no reminders', () => {
      expect(() => {
        sendInvoiceReminder(mockInvoice, 1, mockUser, [mockEmployee]);
      }).toThrow('Invoice has no reminders configured');
    });
  });

  describe('shouldShowValidationModal', () => {
    it('should return true for draft auto-generated invoice', () => {
      const autoGeneratedInvoice: Invoice = {
        ...mockInvoice,
        status: 'draft',
        quoteId: 'Q1',
      };

      expect(shouldShowValidationModal(autoGeneratedInvoice)).toBe(true);
    });

    it('should return false for sent invoice', () => {
      const sentInvoice: Invoice = {
        ...mockInvoice,
        status: 'sent',
        quoteId: 'Q1',
      };

      expect(shouldShowValidationModal(sentInvoice)).toBe(false);
    });

    it('should return false for non-auto-generated invoice', () => {
      const manualInvoice: Invoice = {
        ...mockInvoice,
        status: 'draft',
        quoteId: undefined,
      };

      expect(shouldShowValidationModal(manualInvoice)).toBe(false);
    });
  });
});


